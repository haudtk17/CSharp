------------------------------------------------------------------------
top-level statement
(Only C# 9.0 up)

------------------------------------
- top-level is implicitly wrapped by Main method which is done by CLR

ex:
//file a.cs
Console.WriteLine("something_1");

//file a.cs is the same with b.cs
//file b.cs
using System;
internal class Program{
	public static void Main(string[] args){
		Console.WriteLine("something_1");
	}
}
------------------------------------
- only 1 file in project can have top-level statement
- top-level is place right after "using" directives and right before any namespace/class/method
ex:

//file a.cs
using System;

//---top-level begin here---
Console.WriteLine("Something in top-level statement");
int x = 9;
if(x>=0){
	if(x == 0){
		//....
	}
}
return 0;
//---top-level end here---

//---everything here is ignored(i.e: from now, everything is not executed. But if these code is refered in somewhere, it still ok)
namespace MyNamespace{
	class MyClass{
		//........
	}
}
------------------------------------
- a file with top-level statement can also contain namespaces and type definitions, but they must come after the top-level statement.

ex:
---top-level statement begin---
MyNamespace1.MyClass.method1();	//OK
MyClass.method2();	//OK
---top-level statement end---

namespace MyNamespace1{
	class MyClass{
		public static void method1(){
			Console.WriteLine("Inside MyNamespace1.MyClass.method1");
		}
	}
}

class MyClass{
	public static void method2(){
		Console.WriteLine("Inside MyClass.method2");
	}
}
------------------------------------
- "args" is accessed with top-level statement because top-level statements is implicitly is wrapped by "Main" method

ex:
//file a.cs
//=============
Console.WriteLine("Top-level statement");
Console
//=============

------------------------------------
------------------------------------------------------------------------
null-coalescing operator: "??" and "??="

- null-coalescing is right-associative: evaluated from right to left side.(i.e: a couple of brace is enclosed from right to left)
ex:
	a ?? b ?? c		mean: if b==null ==> (a ?? c) ==> if a==null ==> final result is c
	equivalant: a ?? (b ?? c)
	------------------
	the same maner is true for operator "??="
	ex:
		e ??= f ??= g	mean: if f==null ==> f=g ==> if e==null ==> e=(f ??= g)
		equivalant: e ??= (f ??= g)
		------------------
		string? e = null;
		string? f = null;
		string? g = "hello";

		string? result = e ??= f ??= g;	//result = e = "hello"

		Console.WriteLine($"final: result = '{result}'");
		Console.WriteLine($"boolean evalutation: [result == e == g == \"hello\"] is " +  ((result == e) && (e == g) && (g=="hello")));

		output:
			final: result = 'hello'
			boolean evalutation: [result == e == g == "hello"] is True
		------------------
- real example:
	ex:
		int? a = null;
		int b = a ?? -1;	//b will be equal -1
- ?? and ??= can't be overloaded		
------------------------------------------------------------------------
interpolated string

syntax: ${<interpolatedExpression>[,<width>][:formatString]}
	+ "width" and "formatString" is optional
	+ "interpolatedExpression" is an expression. If this expression is null ==> empty string (i.e: String.Empty)
		ex:
			int? a = null;
			int b = 3;
			string result1 = $"*{a}*";	//result1 = "**"
			string result2 = $"*{b}*";	//result2 = "*3*";
	+ "width" is the minimum number of character.
		+ If result of "interpolatedExpression" has greater of number of character ==> the number of character of "interpolatedExpression" is set for final result.
			ex:
				double d = 0.12345;
				string result = $"{d,3}"; //result = "0.12345" NOT "0.12"
		+ If "width" is positive ==> right-align
			ex:
				int a = 32;
				string result = $"{a,5}";	//result = "   32"
		+ If "width" is negative ==> left-align
			ex:
				int a = 32;
				string result = $"{a-5}";	//result = "32   "
	+ "formatString" is the number of float number
		ex:
			double dValue = 0.1234;
			string result = $"{dValue,2:F3}";		//result = "0.123"
------------------------------------------------------------------------
----------------------------
verbatim string

- to get verbatim ==> use '@' before double quotes
ex:
	string pathName = "C:\\Users\\Desktop\\";
	string verbatimPathName = @"C:\Users\Desktop\";

	string academy = "\x0041cademy";	// "Academy"
	string verbatimAcademy = @"\x0041cademy";	// "\x0041cademy"
----------------------------
use @ as identifier

- place @ before a keyword to treate it as a normal identifier
ex:
	string @for = "Ok";
	Console.Write(@for);		//OK
----------------------------
use _ to separate the view of number
ex:	int x = 1_000;	//x = 1000
----------------------------
in computer, floating number is stored not seem like it be displayed ==> never compare 2 double type
ex:
	double x1 = 0.1;
	double x2 = 0.2;
	bool result = (x1 + x2) == 0.3;	//false because 0.1+0.2 = 0.3000000004
==> solution: for precision, use "decimal" type.
	ex:
		decimal x1 = 0.1m;
		decimal x2 = 0.2m;
		bool result = (x1+x2) == 0.3m;	//true
----------------------------
from C#9, can use just "new()" for create new object
ex:	XmlDocument xml1 = new();	//short version of: XmlDocument xml1 = new XmlDocument();
----------------------------
int x = 921;
string xInString = x.ToString();	//convert an int to string
----------------------------
object ob = 9;
if(ob is int myVar){	//if "ob" is type of "int" ==> assign myVar = ob
	//do something
}
----------------------------
****NOTE: IEEE 754
NaN: Not a Number
NaN is unspecified value ==> two NaN is not equal
double.NaN == double.NaN;	//false
double.NaN != double.NaN;	//true
0.0/0 == 0.0/0;	//false

***NaN is only used for floating number: float and double
----------------------------
switch-case:

#1: like C++ switch-case

#2: relational partern (from C#9.0)
switch(expression){
	case partern_1:
		break;
	case partern_2:
		break;
	case partern_n:
		break;
	default:
		break;
	....
}
ex:
	int x = 8;
	switch(x){
		case > 8:
			//do something
			break;
		case < 8:
			//do something
			break;
		case 8:
			//do something
			break;
	}

#3: relational partern (from C#9.0)
switch(expression){
	case <partern_1> and <partern_2>:
		break;
	case <partern_1> or <partern_2>:
		break;
	case not <partern>:
		break;
}
ex:
    int x = 1;
    switch (x)
    {
        case > 9 and < 100:
            Console.WriteLine("case > 9 and < 100");
            break;
        case < 9 or > 100:
            Console.WriteLine("case < 9 or > 100");
            break;
        case 9:
            Console.WriteLine("case 9");
            break;
        case not 9:
            Console.WriteLine("case not 9");
            break;
    }

#4: case guard - when clause
switch(expression){
	case partern when condition:
		//do something
		break;
}

ex:
	string cmd = "start";
	switch(cmd){
		case string s when s.StartsWith("st"):
			Console.WriteLine("start with 'st' ");
			Console.WriteLine("cmd[3] is '" + cmd[3] + "'");
			break;
		case string s when s.Length > 5:
			Console.WriteLine("length > 5");
			break;
		default:
			Console.WriteLine("Default block");
			break;
	}

#5: return expression
var result = expression switch{
	patern_1 => value_1;
	patern_2 => value_2;
	...
	_ => default_value;
}

ex:
	int x = 9;
	string result = x switch{
		0 => "zero",
		>0 => "positive",
		_ => "negative"
	};

- used as a short version of method
ex:
        static void Main()
        {
            //GetStatus(int) is a local function inside a function
            string GetStatus(int temp) => temp switch
            {
                < 0 => "frezzed",
                >= 0 and <= 10 when temp==9 => "cold",
                > 10 and <= 20 => "cool",
                _ => "hot"
            };

            Console.WriteLine($"Current weather is {GetStatus(10)}");
        }

        //output: "hot"

#6: use with tuple
ex1:
        static void Main()
        {
            string ValidateItem((int, string) infor) => infor switch
            {
                ( < 30, "red") => "too large and not beauty",
                (30, "blue") => "look nice!",
                _ => "disgusting"
            };

            Console.WriteLine(ValidateItem((30, "blue")));
        }

ex2: switch-case with property patern
var person = new { age = 23, name = "John" };
string group = person switch
{
    { age: >=18} when person.name.StartsWith("J") => "f",
    { age: <18 } => "child",
    { age: >=18} => "adult",
    
};
----------------------------
foreach (<data_type> <local_variable_name> in <enumeratation_object>){
	//do something
}
- item of foreach cannot be modified. This mean the item is read-only
ex:
	int[] numbers = {3, 4, 5};
	foreach(int n in number){
		n = 0;	//Error
	}
----------------------------
parsing a string into a data type

- some data type have a "Parse()" method for parsing string to its type. But this way of parsing is throw exception if fail
ex:
	string input = "345";
	int x = int.Parse(input);	//ok: x = 345

	//but
	string input  = "k345";
	int x = int.Parse(input);	//run-time exception
- most of primary types have TryParse() method for parsing the string to its type. This method returns a bool result and take "out" argument for save result
ex:
	string input = "123";
	int result;
	bool check = int.TryParse(input, out result);	//true and result = 123
	
	string input = "a123";
	int result;
	bool check = int.TryParse(input, out result);	//false and result = default value = 0
----------------------------
checked and unchecked keyword

- used in arithmatic operation and type conversion for integral type to define the checking for OverflowException of the number
- checked:	enable compiler checking for overflow/type conversion error at compile time
- unchecked: vice verse with checked
syntax:
	checked{ //statements here}
	unchecked{ //statements here}
ex:
	checked{	//raise an error at compile time
		uint x = uint.MaxValue + 1;
	}

	unchecked{	//not raise an error at compile time ==> error prone
		uint x = uint.MaxValue + 1;	//raise an error at compile time
	}
----------------------------
pass argument to function call

- explicitly specify the argument for each parameter in a function. By this way, the order of parameters is ignored
ex:
	static void DoWork(int number, string message){
		Console.WriteLine("My number is "+number + " and message is " + message);
	}
	
	static void Main(){
		DoWork(message: "The black box", number: 99);	//OK
	}
- the usage of this way must be synchronized. i.e fully use "explicit argument specification"  for all parameters
ex:
	static void Main(){
		DoWork(message: "The black box", number: 99);	//OK
	}

	static void Main(){
		DoWork(message: "The black box", 99);	//Error
	}
	
----------------------------
var keyword
 - "var" is only used with local variable. Compiler infer the type of that variable at compile time


------------------------------------------------------------------------

------------------------------------------------------------------------
#Chapter 4

----------------------------
Add reference project
- by GUI: right click to target project ==> Add ==> Project reference	//vs2022 automatically generate XML content in "project_name.csproj" file
- by XML: in target project .csproj file, add the following tags
	<ItemGroup>
		<ProjectReference Include="\path_to_project\project_name.csproj" />
	</ItemGroup>
----------------------------
caught exception in stack call

- in catch block, after do stuff with exception that have just caught, should use "throw;" and shouldn't use "throw exception_var;"
because, after handling exception, we use "throw;" to re-throw exception to trace where exception come from
while use "throw ex;", only throw exception come from at this line of code (i.e: "throw ex;"), all exception stack above will not be shown
ex:
	void Alpha(){
		try{
			Beta();
		}catch(Exception ex){
			LoggingExceptionToFile(ex);	//caught and logging exception

			//after do stuff with the exception, re-throw exception to stop the program
			throw;	//this line will throw exception from line #10
			
			//bad ideal of throwing exception
			//throw ex;	//if this line is uncommented ==> exception will throw from this line, not from line #10
		}
	}
	void Beta(){
		throw new Exception();	//line #10, this line will throw an exception - where the error begin
	}
	void Main(){
		Alpha();
	}
----------------------------
------------------------------------------------------------------------


------------------------------------------------------------------------
#Chapter5	- OOP

----------------------------
namespace

- if use namespace block  ==> can have multiple namespace in one file .cs ==> all code in this .cs file will belong to this namespace
But if use "namespace name_space;" ==> only 1 namespace in a .cs is allowed ==> explicit namespace
ex:
	//file a.cs	- old format
	namespace Namespace1{
		//code
	}
	namespace Namespace2{
		//code
	}

	//file b.cs	- new format
	namespace MyNamespace;
	//all code in this file will belong to MyNamespace
- Both 2 of ways also still valid. But should use old format with block
----------------------------
- can not place any statement directly in class scope. Only allowed inside method or property
ex:
	public class X{
		public int x;	//just declare. OK
		x = 9;	//execute a statement: ERROR
		public void X(){
			set{
				x = value;	//OK: do action with field x inside a property
			}	
		}
		public int y = 9;	//initialization: OK
	}

- if class have static field and programmer do not explicitly define a "static constructor" ==> compiler automatically
generate one static constructor and then do initialization for that static field.
**NOTE: one class can only have 1 static constructor. This constructor is only called one time when class first be called
- static constructor must not include any access modifier. it implicitly is private, but can't be explicitly defined as private
ex:
	public class X{
		static X(){}	//OK
		private static X(){}	//ERROR
		protected static X(){}	//ERROR
		public static X(){}	//ERROR
	}
-------------------------
instance constructor

- instance constructor can be any of private, protected or public
=========
(*) private
- constructor cannot be called outside of class like: new X()

- Purpose:
+, Single Instance: only 1 instance and can access via property
	ex:
	public class SingletonLogger{
		//only one private field to hold instance of class
		private static SingletonLogger _instance = new SingletonLogger();

		//private constructor prevents creating instance outside of class
		private SingletonLogger(){}
		
		//another instance constructor with difference signature is allowed. But do not do this
		public SingletonLogger(int x){}

		//public static property for access unique instance of class
		public static SingletonLogger Instance => _instance;
	}
	***singleton patern is used in reality situation like:
		+ use only one logger in all project
		+ use only 	connection to database in whole project
		+ use only one configuration manager
		
+, Factory method:	control the creatation of instance of class. via a static method
	ex:
	public class Person{
		private Person(string name, DateTim dob){/*...more code here*/}	//"new Person()" outside of class is not allowed
		public static Person CreateAdult(string name, DateTime dob){
			if(DateTime.Now.Year - dob.Year <18){
				throw new ArgumentException("Must be adult");
			}
			return new Person(name, dob);
		}
	}
+, Prevent inheritance from another class. "private instance constructor" same with "sealed class"
	ex:
	public class X{
		private X(){};
	}
	
	//same with above
	sealed public class X{
	}
	
	public class Y : X{}	//ERROR
	
=========
(*) protected

- only allow create instance from derived class
ex:
	public class Base{
		protected Base(string name){}	//only inside this class or subclass can create instance

		public Base createBase(string name){	//internal factory method. outside class can call this method to create Base instance
			if(name.Length < 5){
				throw new ArgumentException("name must have at least 5 char of length");
			}
			return new Base(name);
		}
	}
	public class Derived : Base{
		public Derived : base(name){}	//subclass can create instance
	}
=========
(*) public
- any code outside can call instance constructor
=========

-------------------------
- we can explicitly define static constructor for class.
- static field is always be assigned first(if have initialized value ==> use this value. Unless this static field is initialized by default value depend to its type)
In static constructor, can overwrite that static field.
ex:
namespace K{ 
	public class X
	{
		//field
		public static int x;       //no initialized value ==> use default value: x = 0
		public static int y = 9;   //use initialized value ==> y = 9

		//static constructor
		static X(){
				Console.WriteLine($"x before override: x = {x}");	//x = 0
				Console.WriteLine($"y before override: y = {y}");	//y = 9
				x = 88;
				y = 33;
				Console.WriteLine($"x after override: x = {x}");	//x = 88
				Console.WriteLine($"y after override: y = {y}");	//y = 33
		}
		public X(){
			//assume have no assignment to x an y here

			Console.WriteLine($"x inside constructor: x = {x}");    //x=88
			Console.WriteLine($"y inside constructor: y = {y}");    //y=33
		}
	}
	
	public class Program
	{
		public static void Main()
		{
            X x1 = new();
            Console.WriteLine($"x inside another call: x = {X.x}");    //X.x=88
            Console.WriteLine($"y inside another call: y = {X.y}");    //X.y=33
        }
    }
}	
----------------------------
access modifier

- in a namespace, only "public" or "internal" is allowed. Because:
	+, public:	allow access both inside and outside of an assembly
	+, internal: allow access only inside an assembly
***namespace is top-level of access, have no thing is parent of namespace ==> cannot use private or protected
- in a namespace, only have: class, struct, enum, interface, delegate and record are allowed.
The field/property, method are belong to class/struct.
Also: event, variable, statement are not allowed in a namespace scope
ex:
    -----------------------
     ////assembly A - i.e: project A
    //file a.cs
 

    namespace A;

    public class X
    {
        internal protected static int number_1;
        private protected int number_2;
    }
    internal class Y
    {
        internal protected int x; //"internal" is disabled because of the declaration of class Y is internal.
                                  //"internal protected int x;" become "protected int x;"
    }
    public class Z : X
    {
        protected int y;    //y is accesible in any class inherite from class Z from both in assembly A or other assembly
        void fx()
        {
            number_2 = 0;   //OK
        }
    }
    public class Z1 : Z
    {
        void f()
        {
            y = 9;  //OK
            number_2 = 0;   //ERROR
        }
    }
    public class Z2
    {
        int w;  //equal: "private int w;"
    }
    class Z3
    {   //internal class Z3
        int u;  //private u;
        void fz()
        {
            X.number_1 = 9;   //OK
        }
    }
	===========
	//file b.cs
	using A;

	public class ZB : Z{	//OK
		void g(){
			y = 8;	//OK
		}
		void gg(){
			Z3 z3 = new();	//OK
			z3.u = 9;	//ERROR
		}
	}
	public class ZC : X{
		void xx(){
			number_1 = 0;	//OK
			number_2 = 0;	//ERROR
		}
	}
	-----------------------
	-----------------------
	////assembly B
	//file c.cs
	using A;

	//public class K : Y{	//ERROR because Y is internal of assembly A
	public class K : Z{	//OK
		void yyyy(){
			Z3 kz3 = new();	//ERROR

			Z2 kz2 = new();	//OK
			kz2.w = 0;		//ERROR
		}
		void k(){
			y = 0;	//OK
		}
	}
	-----------------------	
****sumary
- internal class: only inside assembly
- public class: outside and inside assembly
- internal protected (internal OR protected) only for members(field, property, method) of class: inside assembly or in other assembly but inherited
- private protected (internal AND protected) only for members(field, property, method) of class: only inside assembly and inherited
- class only allowed by either "internal" or "public", not allowed neither for private nor protected
----------------------------
------------------------------------------------------------------------