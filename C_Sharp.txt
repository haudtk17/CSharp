------------------------------------------------------------------------
****NOTE

------------------------------------
- field should always be initialized with value. Should not leave it just by declaration.
	+ value type field: Although field of value type(like: int, double, char,...) is initialized by default value by compiler but should give it initial value for clean and explicit.
	+ reference type field: It give error prone when referencing it later after just declaring without giving it initial value. Except it is accepted to be null and be manipulated at specific time in the future
ex:
	public class Dog{
		public int age;	//OK: default value is given
		public string name;	//compile OK but ERROR PRONE
		public void checkInfo(){
			if(age >= 0){ //pass}
			if(name.Length > 5){	//Oops!!! null not have Length property ==> throw NullReferenceException at runtime
			}
		}
	}
------------------------------------
- C# have 2 kind of constructor:
	+ instance constructor
	+ static constructor
- static constructor always be called - called only one time - before any thing else(but after field initializing) when class is used.
If programmer do not define "static constructor", compiler will auto generate one, and as imagine all field will be assigned with value inside this static constructor.
If programmer explicitly define "static constructor", compiler will NOT generate one.

Follow that, instance constructor is called
ex:
	public class X{
		public int x = 9;	//this will be called #1
		public double y;	//this will also be called #1
		
	}

***one class can ONLY have 1 static constructor
***static constructor can not be called by code, only compiler can call
***static constructor is called by compiler to start any static member inside static constructor
***both static and non-static field is initialized before any non-constructor or static constructor is called:
	+, non-static field is initialized when new object
	+, static field is initialized when class is load at the first time
	flow of class: "class is first load" or "create new" ==> fields ==> constructor
explain more clearer:
If any static member is called first ==> static constructor is called first
If no static member is called first ==> static constructor will be called one time when create new instance of class
------------------------------------
- static constructor is only one in class. because compiler only know 1 static constructor to call
- static constructor is not have access modifier. because it is for compiler, not any code else call
- static constructor exists because it is intended to be used to initialize/load the initial data for class. This data usually is used as single load like: only one logger for the whole of program, only one configuration file,..etc
- inside static constructor may need use complex logic for initialize/load data for class
ex:
	public class Config{
		private static int x;
		private static Loger loger;
		public static Dictionary<string, string> Settings;		

		statics Config(){
			Settings = LoadConfigFromJson("config.json");
		}

		private static LoadConfigFromJson(string path){
			//handling load file
		}
	}
------------------------------------
static constructor

- must be parameterless - i.e: must not have parameter
- must not have access modifier
ex:
	class X{
		static X(int x){}	//ERROR
		static X(){}	//OK
		private static X(){}	//ERROR
		protected static X(){}	//ERROR
		public static X(){}	//ERROR
	}
------------------------------------
***NOTE
- in C#, principle CLR(Common Language Runtime) determines: static constructor is called right before any touch to class. This is a fix rule in all .NET runtime

public class A
{
    static A() { Console.WriteLine("Static ctor A"); }
    public static int value = 42;
}

public class B
{
    static B() { Console.WriteLine("Static ctor B"); }
    public static void Print()
    {
        Console.WriteLine($"A.value = {A.value}");
    }
}

class Program
{
    static void Main()
    {
        B.Print();
    }
}

==> output:
	Static ctor B
	Static ctor A
	A.value = 42

==> explain: because B.Print() is a calling to static method of class B ==> static constructor of class B is called first ==> then static method Print() is called ==> A is touch for the first time(mean have no any touch before this moment) so ==> static constructor of A is called ==> after static constructor of A is called ==> the Console.WriteLine statement inside Print() is continue the remain job

***NOTE:
- for clearly order of static constructor to be load ==> use side effect by explicitly touch the class by order
ex:
public class A
{
    static A() { Console.WriteLine("Static ctor A"); }
    public static int value = 42;
}

public class B
{
    static B() { Console.WriteLine("Static ctor B"); }
    public static void Print()
    {
        _ = A.value;	//touch first to call static constructor of class A
        Console.WriteLine($"A.value = {A.value}");
    }
}

class Program
{
    static void Main()
    {
        B.Print();
    }
}

==> output:
	Static ctor A
	Static ctor B
	A.value = 42
-------------------------------
- static constructor is always be called before static member call(not mention to non-static/static fields initializing)
ex:
public class X
{
    static X()
    {
        Console.WriteLine("static constructor called");
    }
    public static void f()
    {
        Console.WriteLine("static method called");
    }
}

class Program
{
    static void Main()
    {
        X.f();
    }
}

==> output:
	static constructor called
	static method called
------------------------------------
- like C++, if no any instance constructor is defined ==> compiler will auto generate one default constructor with no parameter.
But if have at least one instance constructor ==> default instance constructor will not be generated by compiler
------------------------------------
anonymous expression to use side effect

_ = new X();	//discard assignment: this will create an object of X() but never use this object because "_" is anonymous. This mean "I don't need this variable, just for touch X"
------------------------------------
enum

- to determine(force use) a specific underlying type for an enum ==> use " : desire_type" right after enum name. This forces compiler use desire type for the enum
ex:
	public enum MyEnum : byte{}
	public enum MyEnum : int{}
***Note that: underlying type for enum is integral types such as: int, byte, sbyte, short, long,...  | But char is not allowed.

- if have bitwise(i.e composite variable) for variable ==> adding attribute "[System.Flags]" (or for short [Flags]) at the head of enum definition for easier for debugging.
By this way, .ToString() of the variable will be output the name of enum separatly by "," but not integer number.
Because by default, if not use [Flags] attribute, .ToString() for composited variable(have bitwise) will output integer.
ex:
+ without decoration with [Flags] attribute:
	public enum MyEnum{
		Start = 1,
		DryRun = 2,
		Stop
	}
	MyEnum combined = (MyEnum.Start | MyEnum.DryRun);
	Console.WriteLine(combined);	//output is "3"
+ with decoration with [Flags] attribute:
	[System.Flags]
	public enum MyEnum{
		Start = 1,
		DryRun = 2,
		Stop
	}
	MyEnum combined = (MyEnum.Start | MyEnum.DryRun);
	Console.WriteLine(combined);	//output is "Start, DryRun"

- in C#, if use combine type purpose - mean: enum definition - the good design is use bit number(flag purpose) with base of 2. although odd number in enum still legal.
Because of flag is intent for unique(i.e not overlap) bit design. In the other hand, this design for better debugging purpose with .ToString() method
If not explicitly specify [System.Flags] attribute ==> .ToString() will output in the format of underlying type, not name of enum
(see detail in example code right above)
------------------------------------
const field

- in C#, a constant field is implicitly treated as a static field of class so ==> it will be called by class name. but cannot explicitly mark it with "static" keyword
in C#, const field belong to class, not to instance!!!
ex:
	class Taxi{
		public const string CarType = "4 wheels";	//OK
		//public static const string CarType = "4 wheels";	//ERROR, cannot mark a const field as static
	}
	Taxi x1 = new();
	Console.WriteLine(x1.CarType);	//ERROR
	Console.WriteLine(Taxi.CarType);	//OK
------------------------------------
readonly field

- readonly field initialized only 1 time in the whole of program. can not be changed value
+ static readonly field only be initialized at definition time OR in static constructor
+ non-static readonly field only be initialized at definition time OR in instance constructor OR 
------------------------------------
using static

- use "using static" for importing "public static members" of a "class/struct/enum/interface" from another assembly(don't care "class/struct/enum/interface" is static or non-static)
syntax:
	using static class/struct/enum/interface;
- **NOTE: if 2 class/struct/enum/interface have the same static member ==> still able to use "using static X" but when calling to its member ==> compile error because this is an ambigious call ==> solution: explicitly call with "class_name.member"
- ****NOTE: 
	+ cannot create object from static class. static class is used for utility
	+ static class can be used in another(very often) assembly
------------------------------------
way of pass argument for constructor of class when creating an object

ex:
	public class Person{
		public string Name;
		public string Num;
		public DateTime DateOfBirth;

		public Person(string name, string num){
			Name = name;
			Num = num;
		}
	}

	//by call constructor
	Person gunny1 = new(initialName: "Gunny", homePlanet: "dfasfa"); 	//OK
	Person gunny2 = new Person(initialName: "Gunny", homePlanet: "dfasfa"); //OK
	Person gunny3 = new("Gunny", "23");	//OK

	//by set public field/property
	Person gunny4 = new Person { Name="Gunny", DateOfBirth = DateTime.Now };   //OK

	//by both call constructor and set public field/property
	Person gunny5 = new Person("Gunny", "24") { DateOfBirth = DateTime.Now };    //OK
	***NOTE: must use assign "=" here not ":"
		ex: Person gunny5 = new Person("Gunny", "24") { DateOfBirth: /*here*/ DateTime.Now };    //ERROR
	
****NOTE:
	- "Named argument": explicitly specify parameter(not argument) as argument can be any order
		ex:
			public class Person{
				public Person(string name, int age){	//public instance constructor
					Console.WriteLine($"{name} is {age}");
				}
			}
			public class Program{
				static void Main(){
					Person p1 = new Person("John", 23);	//OK: by order and without explicitly param specify - must be correct order
					Person p1 = new Person(age: 23, name: "John");	//OK: by param explicitly param specify - not need be correct order
				}
			}
	- "Named argument" is only used for "parameter" in constructor/method, NOT for "object initializer"
		ex:
			Person p1 = new Person(initialName: "What", initialAge: 23);	//OK: "initialName" and "initialAge" is parameter
			Person p2 = new Person(){
				Name = "Whay",	//"Name" is a field or property NOT parameter
				Age = 23	//"Age" is a field or property NOT parameter
			}
------------------------------------
tuple

syntax:
	(data_type1, data_type2, data_typeN) var_name = (data_type1_value, data_type2_value, data_typeN_value);

ex:
	(string, int) fruit = ("Apple", 5);

- to access item in tuple, use var_name.ItemN with N is the order of Item in tuple
ex:
	(string, int) fruit = ("Apple", 5);
	string a = fruit.Item1;
	int b = fruit.Item2;

- tuple name inference(only from C# 7.1 up): If tuple is constructed from another object, can use its name to use
ex:
	Person bob = new Person{name = "Bob", age: 23);	//name and age is paramter
	
	var bobInfo = (bob.Name, bob.Age); /*(1)*/	//Name and Age is field or property NOT parameter
	//at (1): bobInfo.Item1= bob.Name; bobInfo.Item2= bob.Age;
	//this means: use "Name" as an alias for "Item1", "Age" is an alias for "Item2"
	//***NOTE:	"Name" and "Age" here are point to the same address with "Item1" and "Item2". NOT the same address with "bob.Name" and "bob.Age", if "bob.Name"/"bob.Age" change value ==> "bobInfo.Name"/"bobInfo.Age" not change
ex2:
	var thing1 = ("Verjf", 4);
	var thing2 = (bob.Name, bob.Children.Count);    //Name and Count of bob will be used as alias. Item1=Name, Item2=Count
	
	//because "Verjf" and 4 are not belong to any object so ==> do not have alias
	Console.WriteLine($"{thing1.Item1} - {thing1.Item2}");

	//cause Name and Children.Count are belong to "bob" object ==> have alias
	Console.WriteLine($"{thing2.Name} - {thing2.Count}");   //#1 same #2
	Console.WriteLine($"{thing2.Item1} - {thing2.Item2}");  //#2 same #1
	
------------------------------------

------------------------------------------------------------------------














------------------------------------------------------------------------
top-level statement
(Only C# 9.0 up)

------------------------------------
- top-level is implicitly wrapped by Main method which is done by CLR

ex:
//file a.cs
Console.WriteLine("something_1");

//file a.cs is the same with b.cs
//file b.cs
using System;
internal class Program{
	public static void Main(string[] args){
		Console.WriteLine("something_1");
	}
}
------------------------------------
- only 1 file in project can have top-level statement
- top-level is place right after "using" directives and right before any namespace/class/method
ex:

//file a.cs
using System;

//---top-level begin here---
Console.WriteLine("Something in top-level statement");
int x = 9;
if(x>=0){
	if(x == 0){
		//....
	}
}
return 0;
//---top-level end here---

//---everything here is ignored(i.e: from now, everything is not executed. But if these code is refered in somewhere, it still ok)
namespace MyNamespace{
	class MyClass{
		//........
	}
}
------------------------------------
- a file with top-level statement can also contain namespaces and type definitions, but they must come after the top-level statement.

ex:
---top-level statement begin---
MyNamespace1.MyClass.method1();	//OK
MyClass.method2();	//OK
---top-level statement end---

namespace MyNamespace1{
	class MyClass{
		public static void method1(){
			Console.WriteLine("Inside MyNamespace1.MyClass.method1");
		}
	}
}

class MyClass{
	public static void method2(){
		Console.WriteLine("Inside MyClass.method2");
	}
}
------------------------------------
- "args" is accessed with top-level statement because top-level statements is implicitly is wrapped by "Main" method

ex:
//file a.cs
//=============
Console.WriteLine("Top-level statement");
Console
//=============

------------------------------------
------------------------------------------------------------------------
null-coalescing operator: "??" and "??="

- null-coalescing is right-associative: evaluated from right to left side.(i.e: a couple of brace is enclosed from right to left)
ex:
	a ?? b ?? c		mean: if b==null ==> (a ?? c) ==> if a==null ==> final result is c
	equivalant: a ?? (b ?? c)
	------------------
	the same maner is true for operator "??="
	ex:
		e ??= f ??= g	mean: if f==null ==> f=g ==> if e==null ==> e=(f ??= g)
		equivalant: e ??= (f ??= g)
		------------------
		string? e = null;
		string? f = null;
		string? g = "hello";

		string? result = e ??= f ??= g;	//result = e = "hello"

		Console.WriteLine($"final: result = '{result}'");
		Console.WriteLine($"boolean evalutation: [result == e == g == \"hello\"] is " +  ((result == e) && (e == g) && (g=="hello")));

		output:
			final: result = 'hello'
			boolean evalutation: [result == e == g == "hello"] is True
		------------------
- real example:
	ex:
		int? a = null;
		int b = a ?? -1;	//b will be equal -1
- ?? and ??= can't be overloaded		
------------------------------------------------------------------------
interpolated string

syntax: ${<interpolatedExpression>[,<width>][:formatString]}
	+ "width" and "formatString" is optional
	+ "interpolatedExpression" is an expression. If this expression is null ==> empty string (i.e: String.Empty)
		ex:
			int? a = null;
			int b = 3;
			string result1 = $"*{a}*";	//result1 = "**"
			string result2 = $"*{b}*";	//result2 = "*3*";
	+ "width" is the minimum number of character.
		+ If result of "interpolatedExpression" has greater of number of character ==> the number of character of "interpolatedExpression" is set for final result.
			ex:
				double d = 0.12345;
				string result = $"{d,3}"; //result = "0.12345" NOT "0.12"
		+ If "width" is positive ==> right-align
			ex:
				int a = 32;
				string result = $"{a,5}";	//result = "   32"
		+ If "width" is negative ==> left-align
			ex:
				int a = 32;
				string result = $"{a-5}";	//result = "32   "
	+ "formatString" is the number of float number
		ex:
			double dValue = 0.1234;
			string result = $"{dValue,2:F3}";		//result = "0.123"
------------------------------------------------------------------------
----------------------------
verbatim string

- to get verbatim ==> use '@' before double quotes
ex:
	string pathName = "C:\\Users\\Desktop\\";
	string verbatimPathName = @"C:\Users\Desktop\";

	string academy = "\x0041cademy";	// "Academy"
	string verbatimAcademy = @"\x0041cademy";	// "\x0041cademy"
----------------------------
use @ as identifier

- place @ before a keyword to treate it as a normal identifier
ex:
	string @for = "Ok";
	Console.Write(@for);		//OK
----------------------------
use _ to separate the view of number
ex:	int x = 1_000;	//x = 1000
----------------------------
in computer, floating number is stored not seem like it be displayed ==> never compare 2 double type
ex:
	double x1 = 0.1;
	double x2 = 0.2;
	bool result = (x1 + x2) == 0.3;	//false because 0.1+0.2 = 0.3000000004
==> solution: for precision, use "decimal" type.
	ex:
		decimal x1 = 0.1m;
		decimal x2 = 0.2m;
		bool result = (x1+x2) == 0.3m;	//true
----------------------------
from C#9, can use just "new()" for create new object
ex:	XmlDocument xml1 = new();	//short version of: XmlDocument xml1 = new XmlDocument();
----------------------------
int x = 921;
string xInString = x.ToString();	//convert an int to string
----------------------------
object ob = 9;
if(ob is int myVar){	//if "ob" is type of "int" ==> assign myVar = ob
	//do something
}
----------------------------
****NOTE: IEEE 754
NaN: Not a Number
NaN is unspecified value ==> two NaN is not equal
double.NaN == double.NaN;	//false
double.NaN != double.NaN;	//true
0.0/0 == 0.0/0;	//false

***NaN is only used for floating number: float and double
----------------------------
switch-case:

#1: like C++ switch-case

#2: relational partern (from C#9.0)
switch(expression){
	case partern_1:
		break;
	case partern_2:
		break;
	case partern_n:
		break;
	default:
		break;
	....
}
ex:
	int x = 8;
	switch(x){
		case > 8:
			//do something
			break;
		case < 8:
			//do something
			break;
		case 8:
			//do something
			break;
	}

#3: relational partern (from C#9.0)
switch(expression){
	case <partern_1> and <partern_2>:
		break;
	case <partern_1> or <partern_2>:
		break;
	case not <partern>:
		break;
}
ex:
    int x = 1;
    switch (x)
    {
        case > 9 and < 100:
            Console.WriteLine("case > 9 and < 100");
            break;
        case < 9 or > 100:
            Console.WriteLine("case < 9 or > 100");
            break;
        case 9:
            Console.WriteLine("case 9");
            break;
        case not 9:
            Console.WriteLine("case not 9");
            break;
    }

#4: case guard - when clause
switch(expression){
	case partern when condition:
		//do something
		break;
}

ex:
	string cmd = "start";
	switch(cmd){
		case string s when s.StartsWith("st"):
			Console.WriteLine("start with 'st' ");
			Console.WriteLine("cmd[3] is '" + cmd[3] + "'");
			break;
		case string s when s.Length > 5:
			Console.WriteLine("length > 5");
			break;
		default:
			Console.WriteLine("Default block");
			break;
	}

#5: return expression
var result = expression switch{
	patern_1 => value_1;
	patern_2 => value_2;
	...
	_ => default_value;
}

ex:
	int x = 9;
	string result = x switch{
		0 => "zero",
		>0 => "positive",
		_ => "negative"
	};

- used as a short version of method
ex:
        static void Main()
        {
            //GetStatus(int) is a local function inside a function
            string GetStatus(int temp) => temp switch
            {
                < 0 => "frezzed",
                >= 0 and <= 10 when temp==9 => "cold",
                > 10 and <= 20 => "cool",
                _ => "hot"
            };

            Console.WriteLine($"Current weather is {GetStatus(10)}");
        }

        //output: "hot"

#6: use with tuple
ex1:
        static void Main()
        {
            string ValidateItem((int, string) infor) => infor switch
            {
                ( < 30, "red") => "too large and not beauty",
                (30, "blue") => "look nice!",
                _ => "disgusting"
            };

            Console.WriteLine(ValidateItem((30, "blue")));
        }

ex2: switch-case with property patern
var person = new { age = 23, name = "John" };
string group = person switch
{
    { age: >=18} when person.name.StartsWith("J") => "f",
    { age: <18 } => "child",
    { age: >=18} => "adult",
    
};
----------------------------
foreach (<data_type> <local_variable_name> in <enumeratation_object>){
	//do something
}
- item of foreach cannot be modified. This mean the item is read-only
ex:
	int[] numbers = {3, 4, 5};
	foreach(int n in number){
		n = 0;	//Error
	}
----------------------------
parsing a string into a data type

- some data type have a "Parse()" method for parsing string to its type. But this way of parsing is throw exception if fail
ex:
	string input = "345";
	int x = int.Parse(input);	//ok: x = 345

	//but
	string input  = "k345";
	int x = int.Parse(input);	//run-time exception
- most of primary types have TryParse() method for parsing the string to its type. This method returns a bool result and take "out" argument for save result
ex:
	string input = "123";
	int result;
	bool check = int.TryParse(input, out result);	//true and result = 123
	
	string input = "a123";
	int result;
	bool check = int.TryParse(input, out result);	//false and result = default value = 0
----------------------------
checked and unchecked keyword

- used in arithmatic operation and type conversion for integral type to define the checking for OverflowException of the number
- checked:	enable compiler checking for overflow/type conversion error at compile time
- unchecked: vice verse with checked
syntax:
	checked{ //statements here}
	unchecked{ //statements here}
ex:
	checked{	//raise an error at compile time
		uint x = uint.MaxValue + 1;
	}

	unchecked{	//not raise an error at compile time ==> error prone
		uint x = uint.MaxValue + 1;	//raise an error at compile time
	}
----------------------------
pass argument to function call

- explicitly specify the argument for each parameter in a function. By this way, the order of parameters is ignored
ex:
	static void DoWork(int number, string message){
		Console.WriteLine("My number is "+number + " and message is " + message);
	}
	
	static void Main(){
		DoWork(message: "The black box", number: 99);	//OK
	}
- the usage of this way must be synchronized. i.e fully use "explicit argument specification"  for all parameters
ex:
	static void Main(){
		DoWork(message: "The black box", number: 99);	//OK
	}

	static void Main(){
		DoWork(message: "The black box", 99);	//Error
	}
	
----------------------------
var keyword
 - "var" is only used with local variable. Compiler infer the type of that variable at compile time


------------------------------------------------------------------------

------------------------------------------------------------------------
#Chapter 4

----------------------------
Add reference project
- by GUI: right click to target project ==> Add ==> Project reference	//vs2022 automatically generate XML content in "project_name.csproj" file
- by XML: in target project .csproj file, add the following tags
	<ItemGroup>
		<ProjectReference Include="\path_to_project\project_name.csproj" />
	</ItemGroup>
----------------------------
caught exception in stack call

- in catch block, after do stuff with exception that have just caught, should use "throw;" and shouldn't use "throw exception_var;"
because, after handling exception, we use "throw;" to re-throw exception to trace where exception come from
while use "throw ex;", only throw exception come from at this line of code (i.e: "throw ex;"), all exception stack above will not be shown
ex:
	void Alpha(){
		try{
			Beta();
		}catch(Exception ex){
			LoggingExceptionToFile(ex);	//caught and logging exception

			//after do stuff with the exception, re-throw exception to stop the program
			throw;	//this line will throw exception from line #10
			
			//bad ideal of throwing exception
			//throw ex;	//if this line is uncommented ==> exception will throw from this line, not from line #10
		}
	}
	void Beta(){
		throw new Exception();	//line #10, this line will throw an exception - where the error begin
	}
	void Main(){
		Alpha();
	}
----------------------------
------------------------------------------------------------------------


------------------------------------------------------------------------
#Chapter5	- OOP

----------------------------
namespace

- if use namespace block  ==> can have multiple namespace in one file .cs ==> all code in this .cs file will belong to this namespace
But if use "namespace name_space;" ==> only 1 namespace in a .cs is allowed ==> explicit namespace
ex:
	//file a.cs	- old format
	namespace Namespace1{
		//code
	}
	namespace Namespace2{
		//code
	}

	//file b.cs	- new format
	namespace MyNamespace;
	//all code in this file will belong to MyNamespace
- Both 2 of ways also still valid. But should use old format with block
----------------------------
- can not place any statement directly in class scope. Only allowed inside method or property
ex:
	public class X{
		public int x;	//just declare. OK
		x = 9;	//execute a statement: ERROR
		public void X(){
			set{
				x = value;	//OK: do action with field x inside a property
			}	
		}
		public int y = 9;	//initialization: OK
	}

- if class have static field and programmer do not explicitly define a "static constructor" ==> compiler automatically
generate one static constructor and then do initialization for that static field.
**NOTE: one class can only have 1 static constructor. This constructor is only called one time when class first be called
- static constructor must not include any access modifier. it implicitly is private, but can't be explicitly defined as private
ex:
	public class X{
		static X(){}	//OK
		private static X(){}	//ERROR
		protected static X(){}	//ERROR
		public static X(){}	//ERROR
	}
-------------------------
instance constructor

- instance constructor can be any of private, protected or public
=========
(*) private
- constructor cannot be called outside of class like: new X()

- Purpose:
+, Single Instance: only 1 instance and can access via property
	ex:
	public class SingletonLogger{
		//only one private field to hold instance of class
		private static SingletonLogger _instance = new SingletonLogger();

		//private constructor prevents creating instance outside of class
		private SingletonLogger(){}
		
		//another instance constructor with difference signature is allowed. But do not do this
		public SingletonLogger(int x){}

		//public static property for access unique instance of class
		public static SingletonLogger Instance => _instance;
	}
	***singleton patern is used in reality situation like:
		+ use only one logger in all project
		+ use only 	connection to database in whole project
		+ use only one configuration manager
		
+, Factory method:	control the creatation of instance of class. via a static method
	ex:
	public class Person{
		private Person(string name, DateTim dob){/*...more code here*/}	//"new Person()" outside of class is not allowed
		public static Person CreateAdult(string name, DateTime dob){
			if(DateTime.Now.Year - dob.Year <18){
				throw new ArgumentException("Must be adult");
			}
			return new Person(name, dob);
		}
	}
+, Prevent inheritance from another class. "private instance constructor" same with "sealed class"
	ex:
	public class X{
		private X(){};
	}
	
	//same with above
	sealed public class X{
	}
	
	public class Y : X{}	//ERROR
	
=========
(*) protected

- only allow create instance from derived class
ex:
	public class Base{
		protected Base(string name){}	//only inside this class or subclass can create instance

		public Base createBase(string name){	//internal factory method. outside class can call this method to create Base instance
			if(name.Length < 5){
				throw new ArgumentException("name must have at least 5 char of length");
			}
			return new Base(name);
		}
	}
	public class Derived : Base{
		public Derived : base(name){}	//subclass can create instance
	}
=========
(*) public
- any code outside can call instance constructor
=========

-------------------------
- we can explicitly define static constructor for class.
- static field is always be assigned first(if have initialized value ==> use this value. Unless this static field is initialized by default value depend to its type)
In static constructor, can overwrite that static field.
ex:
namespace K{ 
	public class X
	{
		//field
		public static int x;       //no initialized value ==> use default value: x = 0
		public static int y = 9;   //use initialized value ==> y = 9

		//static constructor
		static X(){
				Console.WriteLine($"x before override: x = {x}");	//x = 0
				Console.WriteLine($"y before override: y = {y}");	//y = 9
				x = 88;
				y = 33;
				Console.WriteLine($"x after override: x = {x}");	//x = 88
				Console.WriteLine($"y after override: y = {y}");	//y = 33
		}
		public X(){
			//assume have no assignment to x an y here

			Console.WriteLine($"x inside constructor: x = {x}");    //x=88
			Console.WriteLine($"y inside constructor: y = {y}");    //y=33
		}
	}
	
	public class Program
	{
		public static void Main()
		{
            X x1 = new();
            Console.WriteLine($"x inside another call: x = {X.x}");    //X.x=88
            Console.WriteLine($"y inside another call: y = {X.y}");    //X.y=33
        }
    }
}	
----------------------------
access modifier

- in a namespace, only "public" or "internal" is allowed. Because:
	+, public:	allow access both inside and outside of an assembly
	+, internal: allow access only inside an assembly
***namespace is top-level of access, have no thing is parent of namespace ==> cannot use private or protected
- in a namespace, only have: class, struct, enum, interface, delegate and record are allowed.
The field/property, method are belong to class/struct.
Also: event, variable, statement are not allowed in a namespace scope
ex:
    -----------------------
     ////assembly A - i.e: project A
    //file a.cs
 

    namespace A;

    public class X
    {
        internal protected static int number_1;
        private protected int number_2;
    }
    internal class Y
    {
        internal protected int x; //"internal" is disabled because of the declaration of class Y is internal.
                                  //"internal protected int x;" become "protected int x;"
    }
    public class Z : X
    {
        protected int y;    //y is accesible in any class inherite from class Z from both in assembly A or other assembly
        void fx()
        {
            number_2 = 0;   //OK
        }
    }
    public class Z1 : Z
    {
        void f()
        {
            y = 9;  //OK
            number_2 = 0;   //ERROR
        }
    }
    public class Z2
    {
        int w;  //equal: "private int w;"
    }
    class Z3
    {   //internal class Z3
        int u;  //private u;
        void fz()
        {
            X.number_1 = 9;   //OK
        }
    }
	===========
	//file b.cs
	using A;

	public class ZB : Z{	//OK
		void g(){
			y = 8;	//OK
		}
		void gg(){
			Z3 z3 = new();	//OK
			z3.u = 9;	//ERROR
		}
	}
	public class ZC : X{
		void xx(){
			number_1 = 0;	//OK
			number_2 = 0;	//ERROR
		}
	}
	-----------------------
	-----------------------
	////assembly B
	//file c.cs
	using A;

	//public class K : Y{	//ERROR because Y is internal of assembly A
	public class K : Z{	//OK
		void yyyy(){
			Z3 kz3 = new();	//ERROR

			Z2 kz2 = new();	//OK
			kz2.w = 0;		//ERROR
		}
		void k(){
			y = 0;	//OK
		}
	}
	-----------------------	
****sumary
- internal class: only inside assembly
- public class: outside and inside assembly
- internal protected (internal OR protected) only for members(field, property, method) of class: inside assembly or in other assembly but inherited
- private protected (internal AND protected) only for members(field, property, method) of class: only inside assembly and inherited
- class only allowed by either "internal" or "public", not allowed neither for private nor protected
----------------------------
------------------------------------
enum

- to determine(force use) a specific underlying type for an enum ==> use " : desire_type" right after enum name. This forces compiler use desire type for the enum
ex:
	public enum MyEnum : byte{}
	public enum MyEnum : int{}
***Note that: underlying type for enum is integral types such as: int, byte, sbyte, short, long,...  | But char is not allowed.

- if have bitwise(i.e composite variable) for variable ==> adding attribute "[System.Flags]" (or for short [Flags]) at the head of enum definition for easier for debugging.
By this way, .ToString() of the variable will be output the name of enum separatly by "," but not integer number.
Because by default, if not use [Flags] attribute, .ToString() for composited variable(have bitwise) will output integer.
ex:
+ without decoration with [Flags] attribute:
	public enum MyEnum{
		Start = 1,
		DryRun = 2,
		Stop
	}
	MyEnum combined = (MyEnum.Start | MyEnum.DryRun);
	Console.WriteLine(combined);	//output is "3"
+ with decoration with [Flags] attribute:
	[System.Flags]
	public enum MyEnum{
		Start = 1,
		DryRun = 2,
		Stop
	}
	MyEnum combined = (MyEnum.Start | MyEnum.DryRun);
	Console.WriteLine(combined);	//output is "Start, DryRun"

- in C#, if use combine type purpose - mean: enum definition - the good design is use bit number(flag purpose) with base of 2. although odd number in enum still legal.
Because of flag is intent for unique(i.e not overlap) bit design. In the other hand, this design for better debugging purpose with .ToString() method
If not explicitly specify [System.Flags] attribute ==> .ToString() will output in the format of underlying type, not name of enum
(see detail in example code right above)
------------------------------------
const field

- in C#, a constant field is implicitly treated as a static field of class so ==> it will be called by class name. but cannot explicitly mark it with "static" keyword
in C#, const field belong to class, not to instance!!!
ex:
	class Taxi{
		public const string CarType = "4 wheels";	//OK
		//public static const string CarType = "4 wheels";	//ERROR, cannot mark a const field as static
	}
	Taxi x1 = new();
	Console.WriteLine(x1.CarType);	//ERROR
	Console.WriteLine(Taxi.CarType);	//OK
------------------------------------
readonly field

- readonly field initialized only 1 time in the whole of program. can not be changed value
+ static readonly field only be initialized at definition time OR in static constructor
+ non-static readonly field only be initialized at definition time OR in instance constructor OR 
------------------------------------
using static

- use "using static" for importing "public static members" of a "class/struct/enum/interface" from another assembly(don't care "class/struct/enum/interface" is static or non-static)
syntax:
	using static class/struct/enum/interface;
- **NOTE: if 2 class/struct/enum/interface have the same static member ==> still able to use "using static X" but when calling to its member ==> compile error because this is an ambigious call ==> solution: explicitly call with "class_name.member"
- ****NOTE: 
	+ cannot create object from static class. static class is used for utility
	+ static class can be used in another(very often) assembly
------------------------------------
way of pass argument for constructor of class when creating an object

ex:
	public class Person{
		public string Name;
		public string Num;
		public DateTime DateOfBirth;

		public Person(string name, string num){
			Name = name;
			Num = num;
		}
	}

	//by call constructor
	Person gunny1 = new(initialName: "Gunny", homePlanet: "dfasfa"); 	//OK
	Person gunny2 = new Person(initialName: "Gunny", homePlanet: "dfasfa"); //OK
	Person gunny3 = new("Gunny", "23");	//OK

	//by set public field/property
	Person gunny4 = new Person { Name="Gunny", DateOfBirth = DateTime.Now };   //OK

	//by both call constructor and set public field/property
	Person gunny5 = new Person("Gunny", "24") { DateOfBirth = DateTime.Now };    //OK
	***NOTE: must use assign "=" here not ":"
		ex: Person gunny5 = new Person("Gunny", "24") { DateOfBirth: /*here*/ DateTime.Now };    //ERROR
	
****NOTE:
	- "Named argument": explicitly specify parameter(not argument) as argument can be any order
		ex:
			public class Person{
				public Person(string name, int age){	//public instance constructor
					Console.WriteLine($"{name} is {age}");
				}
			}
			public class Program{
				static void Main(){
					Person p1 = new Person("John", 23);	//OK: by order and without explicitly param specify - must be correct order
					Person p1 = new Person(age: 23, name: "John");	//OK: by param explicitly param specify - not need be correct order
				}
			}
	- "Named argument" is only used for "parameter" in constructor/method, NOT for "object initializer"
		ex:
			Person p1 = new Person(initialName: "What", initialAge: 23);	//OK: "initialName" and "initialAge" is parameter
			Person p2 = new Person(){
				Name = "Whay",	//"Name" is a field or property NOT parameter
				Age = 23	//"Age" is a field or property NOT parameter
			}
------------------------------------
tuple

syntax:
	(data_type1, data_type2, data_typeN) var_name = (data_type1_value, data_type2_value, data_typeN_value);

ex:
	(string, int) fruit = ("Apple", 5);

- to access item in tuple, use var_name.ItemN with N is the order of Item in tuple
ex:
	(string, int) fruit = ("Apple", 5);
	string a = fruit.Item1;
	int b = fruit.Item2;

- tuple name inference(only from C# 7.1 up): If tuple is constructed from another object, can use its name to use
ex:
	Person bob = new Person{name = "Bob", age: 23);	//name and age is paramter
	
	var bobInfo = (bob.Name, bob.Age); /*(1)*/	//Name and Age is field or property NOT parameter
	//at (1): bobInfo.Item1= bob.Name; bobInfo.Item2= bob.Age;
	//this means: use "Name" as an alias for "Item1", "Age" is an alias for "Item2"
	//***NOTE:	"Name" and "Age" here are point to the same address with "Item1" and "Item2". NOT the same address with "bob.Name" and "bob.Age", if "bob.Name"/"bob.Age" change value ==> "bobInfo.Name"/"bobInfo.Age" not change
ex2:
	var thing1 = ("Verjf", 4);
	var thing2 = (bob.Name, bob.Children.Count);    //Name and Count of bob will be used as alias. Item1=Name, Item2=Count
	
	//because "Verjf" and 4 are not belong to any object so ==> do not have alias
	Console.WriteLine($"{thing1.Item1} - {thing1.Item2}");

	//cause Name and Children.Count are belong to "bob" object ==> have alias
	Console.WriteLine($"{thing2.Name} - {thing2.Count}");   //#1 same #2
	Console.WriteLine($"{thing2.Item1} - {thing2.Item2}");  //#2 same #1



Deconstructing types

- if class have method with name "Deconstruct" ==> compiler will know and treate this method as deconstructing the object
- this method use for tuple extracting
- this method just for shorthand for compiler. It equals to explicitly call 
- requirement:
	+ signature:	public void Deconstruct(out data_type1 param_name1, out data_type2 param_name2, ....){}
	+ must be public method
	+ parameters must be "out" type
	+ have at least 1 param BUT should use from 2 params up BECAUSE if only 1 param ==> no meaningful and may be compile raise an error!!! although it is legal
ex:
	public class Point{
		public int x;	//field
		public int y;	//field
		
		//special method for compile know
		public void Deconstruct(out int a, out int b){
			a = x;
			b = y;
		}
	}
	
	//usage
	Point p1 = new Point(8, 3);	//assume already define this constructor
	(int xPoint, int yPoint) = p1;	//now: xPoint = 8, yPoint = 3
	//OR this is the same: var (xPoint, yPoint) = p1;	//now: xPoint = 8, yPoint = 3

	//This infer Deconstruct method is the same with the calling:
	Point p1 = new Point(8, 3);	//assume already define this constructor
	int x1;
	int y1;
	bob.Deconstruct(out x1, out y1);	//explicit call
------------------------------------
none, out, ref parameter

- normal value passing: void Func(int x);	//local Func() scope
- out:	cannot read value, only write to but first needed to assign
ex:
	
	void Func1(out int num){
		int k = num;	//ERROR: must assign first
	}
	void Func2(out int num){
		num = 0;		//Yes, must assign before use
		int k = num;	//OK
	}
	void Main(){
		int x = 9;
		Func2(out x);	//OK
	}

- ref:	both in an out value - like "&" in C++. Not need to assign first
ex:
	void Func(ref int num){
		int x = num;	//OK: can read value
		num = 9;		//OK: can write value
	}
	void Main(){
		int x;
		Func(ref x);	//OK
	}
**NOTE: with "out" and "ref" params, must put keyword "out"/"ref" when passing value

- simplied out paramter: from C# 7.0 can declare new local variable inside function call. ***NOTE: never use this way
ex:
	void Func(out int f){	//declare out param as normal
		f = 0;
		f++;
	}
	void Main(){
		//k variable have not defined yet
		Func(out in k);	//call and define k variable. after this call ==> k exist
		Console.WriteLine(k);	//can use k
	}
------------------------------------

------------------------------------------------------------------------